## 简介

工作内容包括：自动化脚本，基础业务实现，中间价，公有服务接口，公有库

## 详情

#### 一.自动化脚本 ./bin

自动化脚本目录在./bin下，主要包括一些数据导入与数据初始化代码生成等自动化任务。

###### automation
	automation是打算存放所有自动化脚本的地方。现里面只有一个generateRestFul.js脚本
	generateRestFul.js脚本是按传入的modelNames为每个需要生成restFul接口的model生成基础增删改查接口
	使用方法： node ./bin/automation/generateRestFul modelNanme1 modelNanme2 ... 
	注意：其中所有的modelName必须是models内存在的模型名（小驼峰）,路由层已添加注释，需手动把{alias}替换成模型的中文名
	并且在路由的index.js中需要手动添加路由文件

###### data
	data目录是存放脚本用到的数据文件夹

###### script/guangzhou
	script下也是存放脚本的地方，主要存放数据自动录入的脚本。现下面只有guangzhou费率录入脚本
	gaunghzou.js是录入广州保险费率的脚本，通过读取参数给定的xls数据文件用node-xls库解析成json格式
	遍历所有sheetName找到name等于广东的sheet,再去格式化sheet存进数据库
	注意里面的conf配置对象，areaId是区域id（这里是广东），carTypeIntervalId是汽车类型区间id（这里是六座以下家用车）
	如果需要录入其他区域的费率，需要将name==="广东"改成指定城市，并修改conf对象，还有传入的文件路径确保正常
	使用方法：node ./bin/script/guangzhou ./bin/data/guangzhou.xls

###### script/initMenu
	初始化菜单的脚本，数据放在./bin/data/directory.json中
	使用方法：node ./bin/script/initMenu

######  createPermissions.js
	这是根据路有的注释配置自动生成路有权限并存库的脚本。
	使用方法：node ./bin/createPermissions

###### data.js
	data.js不是脚本。是旧版本费率的已经格式化好的数据。
	并包含初始化的部分区域数据和汽车类型区间表数据，供importInsuranceRateDate.js脚本使用

###### importInsuranceRateDate.js
	这是关于旧版费率数据初始化脚本。包含费率用到的区域数据初始化，与车辆类型区间表的数据初始化工作。
	使用方法：node ./bin/importInsuranceRateDate ./bin/data

###### exec.js
	自动追加delete_flag脚本。在数据库结构改版的时候，为不存在delete_flag字段的表增加delete_flag字段
	使用方法：node ./bin exec

###### generatorModel.js
	自动生成模型脚本，此脚本根据数据库结构自动生成模型文件。生成规则基于数据库表。
	在node-entities^1.5.x版本以上已经实现模型映射功能，与此脚本规则正好相反，mapping规则是基于本地模型的。
	使用方法：node ./bin/generatorModel

###### initMark.js
	初始化mark表数据脚本。
	使用方法：node ./bin/initMark

###### mergeOrderCode.js
	合并"memberInsurancePrestore", "purchaseOrder", "memberInsurance"集合内code的脚本
	在当时有需求统一此三种集合内code为order集合的code，并保证不能重复。现已不需要了
	使用方法：node ./bin/mergeOrderCode

###### updateDB.js updateIdType.js
	这两个脚本已经启用，在数据库改版时，统一数据库Id类型的脚本，和优惠券策略与策略类型的命名关联修改脚本

#### 二.中间件 ./lib/middleware
	配置在app.js中的一些公共可变化的部分，提取成多个中间件放置在./lib/middleware中
###### auth
	对任何添加了auth的路有将会进行用户认证，权限验证。针对现今版本增加accessToken base64加密解析部分。需要认证的路有需要手动添加此中间件，详细请看代码

###### cors
	配置公共返回头信息，与跨域问题的cors解决方案。

###### fileUpload
	文件上传中间件。对于文件类型的请求，将通过这个中间件统一存储。

###### global
	全局对象的初始化中间件。顺便一提本系统共有两个全局变量LOGININFO与logger。

###### send
	响应数据格式化中间件。对于错误响应与正常响应的数据整理与send。

#### 三.公有库 ./lib/common

###### createCard
	已弃用。曾在做卡券时只能用生产环境公众号，所以配置的用于连生产环境数据库的地方。

###### ERROR
	未使用。曾设想构建自定义异常类，用于系统内所有异常的处理，并对应tip的配置。

###### exportNext
	导出数据的统一处理。功能包括，数据整理为xls Buffer，写入响应流，并设置响应头为xls格式输出

###### fileUpload
	已弃用。放在中间件下了

###### generateCode(name, spliceChar, callback)
	生成12位不重复code的算法，基于mongodb的。
	重构了两种方法generateCode(callback)，generateCode(name, callback)
	其中name为集合名（不同集合的code相互之间隔离不影响）默认值为public，spliceChar为分隔字符串（每四位分隔一次）默认不分割

###### generateStr(length, name, callback)
	生成指定长度的不重复的字符串，基于mongodb。
	重构了两种方法generateStr(callback)，generateStr(length, callback)
	其中length是生成的字符串长度，默认为8，name为集合名，不同集合的code间不影响。默认为randomStr.

###### getRecords
	定时获取客服聊天记录。功能都在文件中实现，使用时只需要在app.js引入即可。

###### logger
	日志系统。配置log4js。提供了三个日志对象。
	consoel: 用log4js的console替换了原生console打印功能，只在控制台输出
	normal: 自动导出日志对象，此日志对象不但会在控制台输出，还会存于mongo中。
	mongo: 此日志对象只存于mongo中

	导出方法：
	auto为导出的方法，用于在app.js中配置访问日志中间件。所有者为normal
	同时auto上也有一个logErr(err, status, req, res)错误日志对象方法，用于项目记录错误日志.所有者为mongo

	全局日志对象： logger
	日志所有者为mongo.logger有三个方法info(str,err, code),warn(str,err, code),error(str,err, code),分别对应三种日志级别

###### returnNext(next)
	路由返回时的数据格式化的callback封装

###### socket
	socket服务端。
	房间号/log：错误日志推送socket,认证字符串为guankaobo的md5值
	使用方法：node socketClient.js http://119.29.19.250:30001/log f7df03cbaa7b2fa623060335e7caeafc

#### 四.公有服务接口 ./lib/service

###### factory
	orm库node-entities的接口封装部分。数据访问的公共查询部分与公共写入部分也配置在此处
	建议：对任何引入的第三方库最好都需要进行封装使用。这样的好处在于在更换同类的工具库时只需要改此处接口文件，就可以完成对接。

###### mongoHelper
	mongoose封装部分，用于导出公有mongoose链接

###### redisClient
	redisClient封装部分。


#### 五.基础业务 business/common
	简单介绍一些复杂的业务实现.基础的增删改查接口与自动化生成的模版类似，只要注意下模型关系就好。详细实现以代码为准，详细介绍请看相关逻辑的代码注释。

###### 用户部分
	本地系统用户概念广泛，按类型分为管理员，门店员工，商户用户，会员用户。任何类型用户拥有的方法权限都在用户业务逻辑中
	用户业务逻辑主要包括：登录（login）与授权（auth）, 用户信息（增删改查），用户账户（增删改查），用户角色，角色权限组，权限组权限的级联管理。
	
###### 保险报价
	保险预报价功能内有四个方法（evaluate,newEvaluate,_evaluate,_newEvaluate）
	其中有new标记的函数，是最新版费改后使用的函数。并且evaluate函数已弃用
	其中带下划线的函数为具体报价函数，不带下划线的函数为参数结构预处理函数
	调用关系: newEvaluate --> _evaluate || _newEvalute。(在newEvaluate中根据区域判断是否为费改区域，然后选择_evaluate或_newEvalute。)




























/**
 * 题目：
 * 
 * 定义一个变量a，使if (a===1 && a===2 && a===3) 为 true

 * 思路与解法：
 * 
 * 大体上看这道题似乎无解，a怎么可能既等于1又等于2又等于三呢？
 * 是的，如果是同一时间的话，a是不可能取多个值的，但是我们做编程最重要的能力就是要
 * 观察变化，上面 a===1 && a===2 && a===3 当中a是存在变化的，既a不是同时等于1，2，
 * 3的，而是先等于1，再等于2，再等于3的。这就是关键。
 * 
 * 那么如果a是一个基础类型变量那么确实做不到，但是我们想假如a是一个函数呢？
 * 如果过函数是不是就比较简单了。因为函数是可以在多次调用中返回不同结果的。
 * 
 * 比如：
 */

let _a = 0;
let a = () => ++_a;

/**
 * 那么 a() === 1 && a() === 2 && a() === 3 就成立。
 * 
 * 但是题目给出的a是不带括号的，也就是说不能是个可直接调用函数，那么怎么办呢？
 * 
 * 我们可以想到在js里一切皆对象，在对象里是获取属性时时可以调用get/set方法的，
 * 那么我们可以定义一个对象，里面定义一个有get的私有变量，在获取时不断加一的方式
 * 来达到这个目的对吧
 * 
 * 比如：
 */

let obj = {
    _a: 0,
    get a() {
        return ++this._a;
    }
}

/**
 * 那么obj.a === 1 && obj.a === 2 && obj.a === 3 也是成立的。
 * 不过问题来了，题目给的只是一个变量a，并没有允许a是一个对象下面的属性。
 * 这样并不符合要求。别着急，上面思路已经解决了问题的关键，我们可以接着上面的思路，
 * 只需要解决如何让一个对象a， 拥有get/set方法即可。
 * 
 * 这时候我们搜索一下js文档看一下js中Object有哪些能用到的函数。
 * 结果发现toString正好可以解决上面的问题,默认情况下在做变量比较时，js会默认把变量类型
 * 统一化处理，让其成为可比较的对象，方式就是调用对象的toString方法。
 * 
 * 好，那么问题就简单了
 * 
 * 我们只需要这样就好了
 */

let a = {
    _a: 0
}
a.__proto__.toString = function() {
    return ++this._a;
}